#### Problem
Given a variety of coin types defining a currency system, find the minimum number of coins required to express a given amount of money.

#### Assumptions
- Assume infinite supply of coins of every type.
- Assume the coin type 1 always exists.
- All input are integers > 0
- No duplicate coin types
- Assume the coin list is already sorted


#### Example
- Input: Coin types: [1, 3, 5]. Amount to express: 9.
- Output: 3

Here are all the unique ways to express 9 as a sum of coins 1, 3 and 5:
1, 1, 1, 1, 1, 1, 1, 1, 1
1, 1, 1, 1, 1, 1, 3
1, 1, 1, 1, 5
1, 1, 1, 3, 3
1, 3, 5
3, 3, 3

#### Solution (Write your code below this line)

What is the maximum length of coin types? 100
Maximum Amount? 100

coin types [1, 3] target = 6
0 1 2 1 2 3 <-- you did this one 6 <- please do this one 7 8 9
0 1 2 3 4 5 6 7 8 9

0 0 0 0 0 0 0


int findMinimumCoins(vector<int> types, int target){
    
    int num[target+1];
    for(int i=1; i<=target; i++){
        num[i] = INT_MAX;
    }
    num[0] = 0;
    
    for(int i=0; i<types.size(); i++){ // n = number of different types
        //for each coin types
        for(int j=types[i]; j<=target; j++){ //m = target value
            
            num[j] = min(num[j], 1 + num[j-types[i]]);
        }
    }
    
    //complexity = O(n x m)
    //space complexity = O(m)
    
    return num[target];
    
    
}



#### Problem
Given a list of numbers, the task is to insert these numbers into a stream and find the median of the stream after each insertion.
The median of a sorted array is defined as the middle element when the number of elements is odd and the average of the
middle two elements when the number of elements is even.

### Example
Input: [3, 8, 5, 2]
Output: [3, 5.5, 5, 4]

#### Step-by-step
Iteration | Stream   | Sorted Stream | Median
1    | [3]     | [3]     | 3
2    | [3, 8]   | [3, 8]    | (3 + 8) / 2 => 5.5
3    | [3, 8, 5]  | [3, 5, 8]  | 5
4    | [3, 8, 5, 2] | [2, 3, 5, 8] | (3 + 5) / 2 => 4
#### Solution (Write your code below this line)


What is maximum Input size: 

3 8 5 2

[3] --> 3

[3, 8] --> 5.5                  //sortedly insert o(n)

[3, 5, 8] -->  5

[2, 3, 5, 8] --> 4  //binary... O(lgn)

4
maxheap


1 2 3 4 5 6 7 8 9



n x n 

time complexity: O(n * lgn)
space complxity: O(n)

class compareMax{
 public:  
    bool operator()(const int &current, const int &other){
        return current < other; // make a max heap
    }
};


class compareMin{
 public:  
    bool operator()(const int &current, const int &other){
        return current > other; // make a max heap
    }
};


vector<int> findMedianList(vector<int> numers){
    priority_queue<int, vector<int>, compareMax) maxHeap;
    priority_queue<int, vector<int>, compareMin) minHeap;
    
    vector<int> ans;
    
    for(int i=0; i<numbers.size(); i++){
        
        if(maxHeap.empty()){
            maxHeap.push(numbers[i]);
            ans.push_back(numbers[i]);
        }else{
            
        }
        
            
        
    }
    
    return ans;
}




